# 计算机网络

 OSI七层模型，从下至上分为 **物理层、数据链路层、网络层、传输层、会话层、表示层、应用层**。



时延：指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。也叫时延或迟延。单位是 S。



## 应用层

- 定义进程间交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如DNS、HTTP、SMTP。

### 域名系统（DNS）

- - -  **DNS ，提供主机名与IP地址之间的相互转换的服务。**
    -  **DNS 域名分层次结构：根域名、顶级域名、二级域名**

- - - ![img](https://cdn.nlark.com/yuque/0/2021/jpeg/22079037/1628174164716-db302010-c28e-4a0d-802e-f6772b0368ee.jpeg)

注意：DNS 涉及两种查询方式：一种是`递归查询(Recursive query)` ，一种是`迭代查询(Iteration query)`。



如果根域名服务器无法告知本地 DNS 服务器下一步需要访问哪个顶级域名服务器，就会使用递归查询；



如果根域名服务器能够告知 DNS 服务器下一步需要访问的顶级域名服务器，就会使用迭代查询。

### 文件传输协议（FTP）

-  **FTP 使用 TCP 进行连接，需要通过两个连接实现文件传输。**

-  - **控制连接：服务器打开 21 端口号等待客户端连接，客户端建立连接后，客户端会通过这个连接将命令给服务器，同时客户端也会通过这个连接接收服务端返回的数据。**

-  - - **数据连接：传输文件数据。**

-  - - - **数据连接有两种模式：主动模式、被动模式**

-  - - - - **主动模式：服务器端主动建立数据连接。**
         - **被动模式：客户端主动建立数据连接。**

-  - - - **主动模式需要客户端开放端口，需要配置主机防火墙，而被动模式要求服务器端开放端口，可能会有安全性问题。**

### 电子邮件协议

- **电子邮件系统组成三部分：邮件服务器、邮件协议、用户代理。**
- **邮件协议：发送协议：SMTP  读取协议：POP3、IMAP （例子：微软、苹果自带邮件绑定）**

- ![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1628175321487-18bd1d3a-9dfa-41d3-86ae-3646896909f4.png)



### HTTP

**HTTP是一种无状态的超文本传输协议，使用明文传输。**

#### HTTP 1.0 与 HTTP 1.1（HTTP 1.0 支持 Get Post Head）（HTTP 1.1 增支持 OPTIONS PUT DELETE TRACE CONNECT）

- **缓存处理：**在 HTTP 1.0 中，主要用的是 Response Header 里的 if-Modified-Since，Expires 来做缓存判断的标准。在 HTTP 1.1 中则是引入了 Etag、if-None-Match等缓存头来控制缓存协议。
- **带宽优化以及网络连接的使用：**在 HTTP 1.0 中，客户端仅仅需要某对象中的单个部分，但却需要服务器将整个对象发送过来，并且也不支持断点续传功能。 HTTP 1.1 在 Request Header 中引入了 range 头域，它只允许仅请求资源的某个部分，即返回码是 206，这样就方便了。

- **错误通知的管理：**在 HTTP 1.1 中新增了 24 个错误状态响应码。如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
- **Host 头处理：**在 HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

- **长连接：**HTTP 1.1 支持长连接（Persistent Connection）和请求的流水线（pending）处理，在一个 TCP 连接上可以传递多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟， 在 HTTP 1.1 中默认开启 Connection: Keep-alive ，一定程度上弥补 HTTP 1.0 每次请求都要创建连接的缺点。



#### SPDY：HTTP 1.x 优化（冷门些，少考）

- 2012年 google 提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了 HTTP1.X 的安全性，具体如下：
- **降低延迟**，针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求 stream 共享一个tcp连接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。

- **请求优先级**（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
- **header压缩。**前面提到 HTTP1.x 的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。

- **基于HTTPS的加密协议传输**，大大提高了传输数据的可靠性。
- **服务端推送**（server push），采用了SPDY的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到sytle.css数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。



#### HTTP 2.0

- HTTP 2.0 是 SPDY 的升级版，但仍在一定的区别。
- 例如，SPDY 仅支持 HTTPS 协议，而 HTTP 2.0 可以支持明文传输。

- **拥有的新特性：**

- - **新的二进制格式：**HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便。
  - **多路复用：**即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

- - **header 压缩：**如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
  - **服务端推送**（server push），同 SPDY 一样，HTTP2.0 也具有server push功能。



#### HTTP 请求方法

- [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET)

GET 方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据。

- [HEAD](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD)

HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。

- [POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)

POST 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。

- [PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT)

PUT 方法用请求有效载荷替换目标资源的所有当前表示。

- [DELETE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE)

DELETE 方法删除指定的资源。

- [CONNECT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT)

CONNECT 方法建立一个到由目标资源标识的服务器的隧道。

- [OPTIONS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS)

OPTIONS 方法用于描述目标资源的通信选项。

- [TRACE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE)

TRACE 方法沿着到目标资源的路径执行一个消息环回测试。

- [PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH)

PATCH 方法用于对资源应用部分修改。



- 在这其中，GET POST HEAD 是简单请求。
- 除了以下字段之外，没有自定义的 Request Header

- - Accept
  - Accept-Language

- - Content-Language
  - Content-Type

- - [DPR](https://link.segmentfault.com/?url=http%3A%2F%2Fhttpwg.org%2Fhttp-extensions%2Fclient-hints.html%23dpr)
  - [Downlink](https://link.segmentfault.com/?url=http%3A%2F%2Fhttpwg.org%2Fhttp-extensions%2Fclient-hints.html%23downlink)

- - [Save-Data](https://link.segmentfault.com/?url=http%3A%2F%2Fhttpwg.org%2Fhttp-extensions%2Fclient-hints.html%23save-data)
  - [Viewport-Width](https://link.segmentfault.com/?url=http%3A%2F%2Fhttpwg.org%2Fhttp-extensions%2Fclient-hints.html%23viewport-width)

- - [Width](https://link.segmentfault.com/?url=http%3A%2F%2Fhttpwg.org%2Fhttp-extensions%2Fclient-hints.html%23width)

- Content-Type的值只有以下三种(Content-Type一般是指在post请求中，get请求中设置没有实际意义)

- - text/plain
  - multipart/form-data

- - application/x-www-form-urlencoded

- 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器 (未验证)

- - XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问

- 请求中没有使用 ReadableStream 对象 (未验证)

##### 简单请求与非简单请求在设置跨域上的区别

- 针对简单请求，在进行 CORS 设置的时候只需要设置

```javascript
Access-Control-Allow-Origin:*
// 如果只是针对某一个请求源进行设置的话，可以设置为具体的值
Access-Control-Allow-Origin: 'http://www.yourwebsite.com'
```

- 针对复杂请求，需要去设置不同的响应头。这是因为在预检阶段进行请求的时候会携带相对对应的请求头信息。

```javascript
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-CUSTOMER-HEADER, Content-Type
```

- 相对应的请求头信息为：

```javascript
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
// 设置max age，浏览器端会进行缓存。没有过期之前真对同一个请求只会发送一次预检请求
Access-Control-Max-Age: 86400
```

### HTTPS

**HTTPS = HTTP + SSL/TLS  （相关问题，CA证书签发、中间人攻击等。）**

#### 对称加密：

- 对称加密，加密与解密用的都是同一把钥匙。对称加密所使用的密钥在内存上相对较小的，密钥的大小决定加密的强弱，相应的，内存占比较大的密钥所需要花费的解密的时间也就越长。故而在设计对成加密算法的时候，就需要按照场景，既要兼顾安全，也要兼顾效率。
- 对称加密有一个较大的缺点，那便是对于密钥的管理与分配。于之前所说，加密与解密用同一把钥匙，就很容易产生安全性问题，中间人可以伪造自身为 Server，劫持数据，于是为了更加安全，便有了 HTTPS，但是不管怎么说，没有最安全的，只有相对安全的。

- 对称加密图解：

![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1629515906093-49474ea3-456c-40a7-ad6c-3074dc80414a.png)



- 双方都将各自有一把钥匙，Client 用这把钥匙加密， Server 用这把钥匙解密。Client 通过某种对称加密算法加密密钥发送给 Server， Server 获取到密钥以及数据后，通过对算法的逆推，对数据进行解密，获取数据。
- 优缺点：简单快速，密钥越大，加密越强，解密越慢，容易被黑客数据劫持。

- 补充图片，加强理解。

![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1629519456795-3d49c677-7e23-48f9-8e8c-4aac4e11a047.png)





#### 非对称加密：

- 非对称加密，使用一对密钥，公钥和私钥。私钥只能由一方保管，不允许外泄，而公钥可以发给任何想要它的人。数据使用公钥加密，私钥解密。
- 图解

![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1629520872979-66abd2c4-f91f-45fc-b139-5c4cde3c708b.png)



- 如此一看，单独使用对称加密或是非对称加密都不是十分安全。PK 是所有人都有，SK 只有服务端有。
- 因此有了 非对称加密 + 对称加密。



#### 对称加密 + 非对称加密 通讯

- 目前较为常用的通讯方式。

![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1629533611546-0fd96026-7482-4131-acca-9e189f2a9d24.png)

- 相当于是首先进行非对称加密，通过非对称加密生成一个唯一值作为后继进行对称加密的 Key，这样可以更加的安全，因为这个 Key 只有Client  和 Server 能够知道。
- 但是即便这也是存在漏洞的，那便是如果一开始，Client 所请求的对象被定向到了黑客所指定的 Server，黑客可以模拟客户端向Server 申请 PK然后存在自身上，作为中间人劫取数据。

- 为了能够修改这一点使得连接更加安全，又在 对称加密 + 非对称加密 的基础上添加了一个 CA 认证。

####  对称加密 + 非对称加密 + CA 证书认证 + Hash 散列算法

- 为了防止中间人攻击，添加 CA 证书认证环节。

![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1629535996889-c1740213-f123-4635-b44f-593dbea0818e.png)



- 图中有提到“返回数据确认收到”，只是在宏观的一个概念，其中另藏玄机。即在 HTTPS 中最为重要的 SSL / TLS 协议
- 其实 TLS 就是标准化后的 SSL ，由 “安全套接字” 成为 “传输层安全协议”。对称加密的非对称传输方式。

![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1629537739002-7219da95-c108-489f-8987-61d1bc743748.png)







### Web 页面请求过程

#### 1、DHCP 配置主机信息 

- **具体过程：略 太长了，不可能背的下来的。**

#### 2、ARP 解析 MAC 地址

- **主机会通过浏览器，依据网站域名以及对应的 IP 地址，生成一个 TCP 套接字，向 HTTP 服务器发送 HTTP 请求。主机会生成一个 DNS 查询报文，该报文会具备 53 端口。**
- **该 DNS 查询报文会被存到目的地址为 对应 DNS 服务器的 IP 地址的数据报中。**

- **接着 这个 IP 数据报会被存到一个以太网帧，发送到网关路由器。**

#### 3、DNS 域名解析

- **知晓网关路由器的 MAC 地址之后， 继续进行 DNS 的解析过程。**
- **网关路由器接收到包含 DNS 查询报文的以太网帧之后，抽取该 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由。**

- **到达 DNS 服务器之后， DNS 服务器会抽出本地生成的 DNS 查询报文，根据 DNS 查询报文查询在 DNS 数据库中查找待解析的域名。**
- **查询到 DNS 记录之后，DNS 服务器发送 DNS 回答报文， 将该报文段存入 UDP 报文段，并将该 UDP 存入 IP 数据报，数据报通过路由反向转发回到网关路由器，并经过以太网交换机到达主机。**

#### 4、HTTP 请求

- **主机获取到返回的 IP 数据报，（****主机生成 TCP 套接字，用于向 Web 服务器发送 Get 请求报文。****） 主机与 HTTP 服务器向通过三次握手建立连接。生成一个具有端口号信息的 SYN 报文，并将该报文信息发送给HTTP服务器，服务器接收到该数据报文，生成 TCP SYN ACK 报文返回给主机。在建立连接之后，主机浏览器生成 Get 请求报文交付 HTTP 服务器。服务器从套接字报文读取 Get 报文，并生成 HTTP 响应报文， 将加载 Web 页面内容的资源存入响应报文主体返回主机。浏览器接收到 HTTP 响应报文，抽出报文主体中的网页内容，进行页面渲染，展示内容。**







## 传输层

- **传输层主要关系到了TCP、UDP。**
- **TCP 与 UDP 两者的区别在于，TCP 是面向连接、字节流的，头部字节需要20个字节，具有拥塞、流量控制，提供的是全双工协议，便与连接对象的关系为一对一，其特点个人认为就是稳定。而 UDP 则是无连接的，面向报文，头部字节仅需要8个字节，不具备拥塞控制，与连接对象的关系可以是 一对一 、 一对多、 多对一、 多对多，其主要的特点个人理解为就是传输数据，疯狂地尽力地传，在生活常见的用到 UDP 的就有直播。**



### TCP 三次握手、四次挥手

- **三次握手：客户端、服务器端的 PCB 进程块被唤醒，客户端生成 SYN 数据包发送给服务器，同时客户端还生成一个随机数 X 存入该数据包中，服务器根据收到的 SYN 数据包，生成 SYN-ACK 数据包返还给客户端，同时服务器生成一个随机数 Y 作为 SYN = Y，ACK确认序列号确认接收客户端数据，被赋值ACK = X + 1，两者均存入 SYN-ACK 数据包。客户端接收 SYN-ACK 数据包之后，生成 ACK 数据包发送给服务器，服务器解析 ACK 数据包， 确认数据传递成功，ACK = ACK + 1，连接建立。**

![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1628403246825-cec403b0-4fa6-40ec-9ee9-b1f4e9b6ab40.png)

- **三次握手的原理：****第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。**
- **四次挥手****：**![img](https://cdn.nlark.com/yuque/0/2021/jpeg/22079037/1628403589303-c8be03a1-655f-4340-8ced-1cf9ba2bb417.jpeg)

- **客户端发送 连接释放报文 FIN = 1，进入连接释放等待FIN-WAIT，服务器接收后发出 ACK 数据包，此时 TCP 会进入半关闭状态，仅支持服务器传输数据给客户端，当服务器传输完所需数据后，连接将不再需要，服务器会发送包含 FIN、ACK 的数据包给客户端，客户端接收确认数据，发送 ACK 数据包给服务器进行最后的连接释放确认，进入 TIME-WAIT 状态，并等待 2MSL（报文最大存活时间）以保证 ACK 数据包能够被服务器接收，且没有旧数据进入到新连接中。**



### TCP 的可靠传输：TCP通过超时重传来实现可靠连接，超时重传： 如果发出的报文段在一定时间内没有得到确认报文的回传，这个报文段将会得到重传。我们将发出报文到接收报文的这一段时间称为一个RTT。

### TCP 滑动窗口： 略。

### TCP 拥塞控制：避免网络环境拥堵。

#### ![img](https://cdn.nlark.com/yuque/0/2021/jpeg/22079037/1628404777924-201b00a0-7737-4c25-abc0-28ffe5b1324e.jpeg)

**TCP 通过拥塞控制、慢开始、快恢复、快重传这四种算法实现拥塞控制。**

![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1628405076951-825ce64a-0e96-42df-96b8-cfd73b73e1ca.png)

### TCP 流量控制：

- 通过改变 TCP 窗口，控制发送方发送数据速率，以方便接收方能够及时接收。



### SYN 泛洪攻击 (vlan洪水)

- 



### TCP 与 UDP 区别



## 网络层

- **通过 IP 协议，把异构的物理网络连接在一次。**
- **ARP 协议**



## 物理层

- **提供通信方式： 半双工传输、全双工传输、单工传输**



## HTTP 状态码

- 1**：请求收到，继续处理
- 2**：操作成功收到，分析、接受

- 3**：完成此请求必须进一步处理
- 4**：请求包含一个错误语法或不能完成

- 5**：服务器执行一个完全有效请求失败
- 再具体就如下：

- - 100——客户必须继续发出请求
  - 101——客户要求服务器根据请求转换HTTP协议版本

- - 200——交易成功
  - 201——提示知道新文件的URL

- - 202——接受和处理、但处理未完成
  - 203——返回信息不确定或不完整

- - 204——请求收到，但返回信息为空
  - 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件

- - 206——服务器已经完成了部分用户的GET请求
  - 300——请求的资源可在多处得到

- - 301——删除请求数据
  - 302——在其他地址发现了请求数据

- - 303——建议客户访问其他URL或访问方式
  - 304——客户端已经执行了GET，但文件未变化

- - 305——请求的资源必须从服务器指定的地址得到
  - 306——前一版本HTTP中使用的代码，现行版本中不再使用

- - 307——申明请求的资源临时性删除
  - 400——错误请求，如语法错误

- - 401——请求授权失败
  - 402——保留有效ChargeTo头响应

- - 403——请求不允许
  - 404——没有发现文件、查询或URl

- - 405——用户在Request-Line字段定义的方法不允许
  - 406——根据用户发送的Accept拖，请求资源不可访问

- - 407——类似401，用户必须首先在代理服务器上得到授权
  - 408——客户端没有在用户指定的饿时间内完成请求

- - 409——对当前资源状态，请求不能完成
  - 410——服务器上不再有此资源且无进一步的参考地址

- - 411——服务器拒绝用户定义的Content-Length属性请求
  - 412——一个或多个请求头字段在当前请求中错误

- - 413——请求的资源大于服务器允许的大小
  - 414——请求的资源URL长于服务器允许的长度

- - 415——请求资源不支持请求项目格式
  - 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段

- - 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求
  - 500——服务器产生内部错误

- - 501——服务器不支持请求的函数
  - 502——服务器暂时不可用，有时是为了防止发生系统过载

- - 503——服务器过载或暂停维修
  - 504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长

- - 505——服务器不支持或拒绝支请求头中指定的HTTP版本



# 浏览器缓存

- **浏览器每次发起请求时，会现在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则会使用本地缓存。否则，则会向服务器发起请求并携带缓存标识。根据是否需要向服务器发送 HTTP 请求，将缓存过程分为以下两个部分：强缓存、协商缓存。**
- **强缓存：服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用本地缓存，如果不在时间内，则使用协商缓存。**

- **协商缓存：让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，并由服务器进行校验，返回 304 状态码时，浏览器直接使用缓存。**



**HTTP缓存都是从第二个请求开始的：**

- **第一次请求资源时，服务器返回资源，并在 Response Header 中回传资源的缓存策略。**
- **第二次请求时，浏览器判断这些参数，命中缓存就直接返回 200 ，否则就把请求参数加到 Request Header 头传给服务器，看是否命中协商缓存， 命中则返回 304 ，否则服务器就会返回新的资源。**

- ![img](https://cdn.nlark.com/yuque/0/2021/png/22079037/1628926213674-78983f01-9803-4a8d-a027-a3d833fded72.png)



## 强缓存

- **强缓存命中则直接读取浏览器本地的资源，在 network 中显示的是 from memory 或 from disk**
- **控制强制缓存的字段有：Cache-Control（HTTP 1.0）、 Expires （HTTP 1.1）。**

- **Cache-Control 是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。**
- **Expires 是一个绝对时间。用以表达在这个时间点之前发起的请求可以直接从浏览器中读取数据，而无需发起请求。**

- **论优先级，Cache-Control 要高于 Expires。 前者的出现是为了解决 Expires 在的浏览器时间被手动更改导致缓存判断错误的问题。**



### Cache-Control

- **常用值**

- - `**max-age**`**：即最大有效时间。**
  - `**must-revalidate**`**：如果超过了** `**max-age**` **的时间，浏览器必须向服务器发送请求，验证资源是否还有效。**

- - `**no-cache**`**：不使用强缓存，需要与服务器验证缓存是否新鲜。**
  - `**no-store**`**: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。**

- - `**public**`**：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)**
  - `**private**`**：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。**

- **该字段可以在请求头或相应头设置，可以组合多种指令：**

- - **可缓存性：**

- - - **public: 浏览器和缓存服务器都可以缓存这个页面信息。**
    - **private: 代理服务器不可缓存，只能被单个用户缓存。**

- - - **no-cache: 浏览器和服务器都不应该缓存页面信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。**
    - **only-if-cache: 客户端只接受已缓存的响应。**

- - **到期：**

- - - **max-age=：缓存存储的最大周期，超过这个周期被认为过期。**
    - **s-maxage=：设置共享缓存，比如can。会覆盖max-age和expires。**

- - - **max-stale[=]：客户端愿意接收一个已经过期的资源**
    - **min-fresh=：客户端希望在指定的时间内获取最新的响应**

- - - **stale-while-revalidate=：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应**
      **的时间长度。**
    - **stale-if-error=：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。**

- **重新验证和重新加载**

- - **must-revalidate：如页面过期，则去服务器进行获取。**
  - **proxy-revalidate：用于共享缓存。**

- - **immutable：响应正文不随时间改变。**

- **其他**

- - **no-store：绝对禁止缓存**
  - **no-transform：不得对资源进行转换和转变。例如，不得对图像格式进行转换。**

**优势：解决了 Expires 服务器和客户端相对时间的问题。**



## 协商缓存

- **协商缓存的状态码由服务器策略返回 200 or 304。**
- **当浏览器的强缓存失效的时候或者请求头中设置了不进行强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，就会将这两个属性值发送到服务器验证是否命中协商缓存。若命中，则会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或则 Etag 。**

- **对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此在响应体体积上的节省是它的优化点。**
- **协商缓存有 2 组字段，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和 Etag/If-None-match（http1.1）**

- **Last-Modified/If-Modified-since 表示的是服务器的资源最后一次修改的时间；****Etag/If-None-match 表示的是服务器资源的唯一标识。**



### Last-Modified / If-Modified-Since

- **服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间。浏览器将这个值和内容一起记录在缓存数据库中。下一次请求相同资源的同时，浏览器从自己的缓存中找出 “不确定是否过期” 的缓存，因此在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段。服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行比较。如果相等，则表示未进行修改，响应 304，反之则表示修改了，相应 200，并返回数据。**





### Etag / If-None-Match

- `**Etag**` **存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的** `**Etag**` **字段。之后的流程和** `**Last-Modified**` **一致，只是** `**Last-Modified**` **字段和它所表示的更新时间改变成了** `**Etag**` **字段和它所表示的文件 hash，把** `**If-Modified-Since**` **变成了** `**If-None-Match**`**。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。**
- **浏览器在发起请求时，服务器返回在 Response header 中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的Etag值赋值给If-No-Matched并添加在 Request Header 中。服务器将浏览器传来的if-no-matched跟自己的本地的资源的ETag做对比，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。**

- **Etag 的优先级高于 Last-Modified**。
- **优势特点**

- - **1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。**
  - **2、不存在版本问题，每次请求都回去服务器进行校验。**

- **劣势特点**

- - **1、计算 ETag 值需要性能损耗。**
  - **2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现 ETag 不匹配的情况。**





## 拓展

### BGP 协议

- 边界网关协议 BGP ，是一种实现自治系统 AS 之间的路由可达并选择最佳路由的距离矢量路由协议。
- BGP 是一种外部网关协议（EGP），与 OSPF 、 RIP 等内部网关协议（IGP）不同，着眼点不在于自动发现网络拓扑，而在于 AS 之间选择最佳路由和控制路由的传播。



#### BGP 协议的特性

- **BGP 是自治系统外部路由协议，用来自 AS 之间传递路由信息。**
- **路径矢量路由协议，从设计上避免了环路的发生。**其路由信息中携了所经过的全部 AS 路径列表。这样，接收该路由信息的 BGP 路由器可以明确的知道此路由信息是否源于自己的 AS。如果是源于自己的 AS， BGP 就会丢弃此路由，这样就根本的解决了 AS 之间产生环路的可能性。

- **使用 TCP 作为传输协议，端口号是 179 。** 天然的可靠传输机制、重传、排序等机制来保证 BGP 协议信息交换的可靠性。
- **支持 CIDR （无类域间路由）和路由聚合。** 可以将一些连续的子网聚合陈较大的子网（突破了自然分类的限制），从而可以在一定程度上控制路由表的快速增长，并降低了路由查询的复杂度。

- **路由附带丰富的属性。**
- **只发送增量路由更新，**BGP 只发送更新的路由信息，大大减少了 BGP 传播路由所占的带宽 **。** 

### 

