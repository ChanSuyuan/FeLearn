+ # 前端安全

  

  ## 跨站脚本攻击 XSS

  **就是攻击者想尽一切办法将可以执行的代码注入到网页中。**

  - **存储型（ Server 端）**
  
  - - **场景：见于带有用户保存数据的网站功能，如 论坛发帖、 商品评论、 用户私信等。**
    - **攻击步骤：攻击者将恶意代码提交到目标网站的数据库中。用户打开目标网站时，服务端将恶意代码从数据库中提取出来，拼接在 HTML 中返回给浏览器。用户浏览器在收到响应后解析执行，混在其中的恶意代码也被同时执行。恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作。**

  - **反射型（ Server 端）**
  
  - - **与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码存在 URL 上。**
    - **场景：通过 URL 传递参数的功能，如网站搜索、跳转等。**

  - - 攻击步骤： 攻击者构造出特殊的 URL ，其中包含恶意代码。用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。用户浏览器接收到响应之后解析执行，混在其中的恶意代码也被执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

  - DOM型 （浏览器）
  
  - - DOM 型的 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于 JavaScript 自身的安全漏洞。
    - 场景： 通过 URL 传递参数的功能，如网站搜索、跳转等。

  - - 攻击步骤：攻击者构造出特殊的 URL，其中包含恶意代码。用户打开带有恶意代码的 URL ，用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定操作。

  

  ## XSS 预防 （防止攻击者提交恶意代码，防止浏览器执行恶意代码）

  - **对数据进行严格的输出编码：如 HTML 元素的编码，Js 编码等。**

  - - **避免拼接 HTML。 React 避免使用 dangerouslySetInnerHTML**

  - **CSP HTTP Header, 即 Content-Security-Policy、X-XSS-Protection**
  
  - - **增加攻击难度，配置 CSP （本质是建立白名单，由浏览器进行拦截）**
    - Content-Security-Policy: default-src 'self' -所有内容均来自一个站点的同一个源。
  
  - - Content-Security-Policy: default-src 'self' *.trusted.com -允许内容来自信任的域名以及其子域名。
    - Content-Security-Policy: default-src https://yideng.com - 该服务器仅允许通过 HTTPS 的方式并仅从 yideng.com 域名来访问文档。
  
  - **输入验证：****比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断。**
  - **开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。**

  

  ## CSRF 跨站请求伪造

  **攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户被攻击的网站执行某项操作的目的。**

  
  
  - **攻击流程举例：受害者登录 a.com, 并保留登陆凭证（Cookie）。攻击者引诱受害者访问了 b.com。b.com 向 a.com 发送了一个请求： a.com/act=xx 浏览器会默认携带 a.com 的 Cookie 。 a.com 接受到请求之后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发出的请求。a.com 以受害者的名义执行了 act=xx 。攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。**
  - **攻击类型：**
  
  - - **GET 型：如在页面的某个 img 中发起一个 get 请求。**
    - **POST 型： 通过自动提交表单到恶意网站上。**

  - - **链接型： 需要诱导用户点击链接。** 

  

  ## CSRF 预防方案

  **CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提高安全性。**
  
  - **同源检测： 通过 Header 中的 Origin Header、 Referer Header 确定，但不同浏览器可能会有不一样的实现，不能完全保证。**
  - **CSRF Token 校验：将 CSRF Token 输出到页面中（通常保存在 Session 中），页面提交的请求会携带这个 Token ，服务器验证 Token 。**

  - **双重 Cookie 验证：**

  - - **流程：**
  
  - - - **步骤1: 用户访问网站页面时，向请求域名注入一个 Cookie ，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。**
      - **步骤2: 在前端向后端发送请求时，取出 Cookie ，并添加到 URL  的参数中 （接上例POST** https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）**）**

  - - - **步骤3: 后端接口验证 Cookie 中的字段与 URL 参数属否一致，不一致则拒绝。**

  - - **优点：**
  
  - - - **无需使用 Session ，适用面更广，易于实施。**
      - **Token 存储在客户端中，不会给服务器带来压力。**

  - - - **相对于 Token ，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。**

  - - **缺点：**
  
  - - - Cookie 中添加了额外的字段。
      - 如果有其他漏洞（例如 XSS），攻击者可以注入 Cookie，那么该防御方式失效。
  
  - - - 难以做到子域名的隔离。
      - 为了确保 Cookie 的传输安全，采用这种防御方式的最好确保用整站 HTTPS 的方式，如果还没切 HTTPS 的使用这种方式也会有风险。

  - Samsite Cookie 属性： Google 起草了一份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 Samsite 属性，它用来标明这个 Cookie 是个 ‘ 同站 Cookie ’ ，同站 Cookie 只能作为第一方 Cookie ，不能作为第三方 Cookie ， Samsite 有两个属性值， Strict 为任何情况下都不可以作为第三方 Cookie， Lax 为第三方 Cookie，但必须是 GET 请求。

  

  ## Iframe 安全

  说明：
  
  - 嵌入第三方 Iframe 会有很多不可控的问题，同时第三方 Iframe 出现问题或是被劫持之后，也会诱发安全问题。
  - 点击劫持

  - - 攻击者将目标网站通过 Iframe 前套的方式嵌入到自己的网页上，并将 Iframe 设置为透明，诱导用户点击。

  - 禁止自己的 Iframe 中的链接外部网站的 Js 。

  

  ## Iframe 预防方案
  
  - 为 Iframe 设置 sandbox 属性，通过它可以对 Iframe 的行为进行各种限制，充分实现 “最小权限” 原则。
  - 服务端设置 X-Frame-Options Header 头，拒绝页面被嵌套，X-Frame-Options 是 HTTP 响应头中用来告诉浏览器一个页面是否可以潜入 <iframe> 中
  
  - - eg. X-Frame-Options: SAMEORIGIN
    - SAMEORIGIN：iframe 页面的地址只能为同源域名下的页面。
  
  - - ALLOW-FROM：可以嵌套在指定来源的 iframe 里。
    - DENY： 当前页面不能嵌套在 iframe 里。
  
  - 设置 CSP 即 Content-Security-Policy 请求头。
  - 少用 Iframe

  

  ## HTTPS

  描述：黑客可以利用 SSL Stripping 这种攻击手段，强制让 HTTPS 降级为 HTTP，从而进行中间人攻击。

  预防方案：使用 HSTS（HTTP Strict Transport Security），它通过下面这个 HTTP Header 以及一个预加载的清单，来告知浏览器和网站进行通信的时候强制性的使用 HTTPS ，而不是通过明文的 HTTP 进行通行。这里的 “强制性” 表现为浏览器无论在任何情况下都直接向服务器端发起 HTTPS 请求，而不再像以往那样从 HTTP 跳转到 HTTPS。 另外，当遇到证书或者链接不安全的时候，则首先告警用户，并且不再用户选择是否继续进行不安全的通信。

  

  ## 静态资源验证完整性

  描述：使用 内容分发网络（CDNs）在多个站点之间共享脚本和样式等文件可以提高站点性能并节省带宽。然而，使用 CDN 也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中，或者替换。因此可能潜在地攻击所有该 CDN 获取文件的站点。 

  预防：将使用 Base 64 编码过后的文件哈希值写入所引用的 <script> 或标签 integrity 属性值中即可启用子资源完整性能。

  

  ## 中间人攻击

  中间人攻击（Man-in-the-middle attack, MITM），指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上，整个对话都被攻击者进行了窃听、篡改甚至完全控制。没有进行严格的证书校验是中间人攻击的着手点。目前大多数加密协议都提供了一些较为特殊的认证方法以阻止中间人攻击，如 SSL （安全套接字）协议以验证参与通讯的用户的证书是否有权威、受信任的数字证书认证机构颁发，并且能执行双向身份认证。攻击场景如用户在一个未加密的 WiFi下访问网站。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。

  

  场景：
  
  - 在一个未加密的 WI-FI 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络。
  - Fiddler / Charles 代理工具。

  过程：

  - 客户端发送请求到服务端，请求被中间人截获。服务器向客户端发送公钥，中间人截获公钥，保留在自己手上，然后自己生成一个【伪造的】公钥，发送给客户端。 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。中间人获得加密的 hash 值，用自己的私钥解密获取真秘钥，同时生成假的加密 hash 值，发给服务器。服务器用私钥解密获取假秘钥，然后加密数据传输给客户端。

  

  使用抓包工具 fiddle 进行举例说明
  
  1. 1. 首先通过一些途径在客户端安装证书
     2. 然后客户端发送连接请求，fiddle 在中间截取请求，并返回自己伪造的证书
  
  1. 1. 客户端已经安装了攻击者的根证书，所以验证通过
     2. 客户端就会正常和fiddle进行通信，把 fiddle 当作正确的服务器

  1. 1. 同时fiddle会跟原有的服务器进行通信，获取数据以及加密的密钥，去解密密钥

  

  常见的攻击方式：
  
  - 嗅探：一种用来捕获流进和流出的网络数据包的技术，就好似是监听电话一般。
  - 数据包注入：攻击者会将恶意数据包注入到常规数据中，而由于这些恶意数据包是藏在正常数据包之中，用户、系统难以发现。
  
  - 会话劫持：当我们进行一个网站的登录的时候到退出登录这个时候，会产生一个会话，这个会话是攻击者用来攻击的首要目标，因为这个会话，包含了用户大量的数据和私密信息。
  - SSL 剥离：HTTPS是通过SSL/TLS进行加密过的，在SSL剥离攻击中，会使SSL/TLS连接断开，让受保护的HTTPS，变成不受保护的HTTP（这对于网站非常致命）
  
  - DNS 欺骗：攻击者往往通过入侵到 DNS 服务器，或者篡改用户本地 hosts 文件，然后去劫持用户发送的请求，然后转发到攻击者想要转发的服务器。
  - ARP 欺骗：ARP(address resolution protocol) 地址解析协议，攻击者利用 ARP 的漏洞，用当前局域网之间的一台服务器，来冒充客户端想要请求的服务端，向客户端发送自己的 MAC 地址，客户端无从得到真正的主机的 MAC 地址，所以，他会把这个地址当作真正的主机来进行通信，将 MAC 存入 ARP 缓存表。

  - 代理服务器。

  

  预防方案：
  
  - 使用可行的第三方 CA 厂商。
  - 确认访问的网站是 HTTPS ，确保网站使用 SSL ，确保禁用一些不安全的 SSL，只开启： TLS1.1 TLS1.2

  

  ## SQL注入

  描述：通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终到达欺骗数据库服务器执行恶意的 SQL 命令，从而达到和服务器进行直接的交互。

  

  预防方案：后台进行输入验证，使用参数化查询，尽量避免拼接 SQL 。

  

  ## 前端数据安全

  描述：反爬虫。如猫眼电影、天眼查等。

  

  预防方案：
  
  - font-face拼接方式：猫眼电影、天眼查。
  - background 拼接： 美团
  
  - 伪元素隐藏：汽车之家
  - iframe 异步加载： 网易云音乐